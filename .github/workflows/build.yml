name: CI Build & Audit

on:
  pull_request:
    branches: [ main ]
    paths:
      - 'Containerfiles/**'
      - 'versions.json'

jobs:
  matrix-setup:
    name: Resolve Build Matrix
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.matrix.outputs.matrix }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Compute selective matrix
        id: matrix
        env:
          BASE_SHA: ${{ github.event.pull_request.base.sha }}
        run: |
          set -euo pipefail

          # 1. Enumerate all valid {version, variant, arch} triples from versions.json
          ALL_TRIPLES=$(jq -c '[to_entries[] | .key as $ver | .value | to_entries[] |
            select(.value | type == "object" and has("base")) |
            .key as $var | .value | to_entries[] |
            select(.key != "base" and (.value | type == "object" and has("digest"))) |
            {version: ($ver | ltrimstr("ubi")), variant: $var, arch: .key}]' versions.json)
          echo "All valid triples: $ALL_TRIPLES"

          # 2. Detect changed Containerfiles â†’ (version, variant) pairs
          CHANGED_PAIRS="[]"
          while IFS= read -r file; do
            [[ -z "$file" ]] && continue
            basename=$(basename "$file" .Containerfile)
            if [[ "$basename" =~ ^ubi([0-9]+)-(.+)$ ]]; then
              ver="${BASH_REMATCH[1]}"
              var="${BASH_REMATCH[2]}"
              CHANGED_PAIRS=$(echo "$CHANGED_PAIRS" | jq -c --arg v "$ver" --arg r "$var" \
                '. + [{version: $v, variant: $r}]')
            fi
          done < <(git diff --name-only "${BASE_SHA}" HEAD -- 'Containerfiles/*.Containerfile' 2>/dev/null || true)
          echo "Changed Containerfiles: $CHANGED_PAIRS"

          # Expand changed pairs to all arches for those pairs from ALL_TRIPLES
          CHANGED_CF=$(jq -c --argjson pairs "$CHANGED_PAIRS" \
            '[.[] | . as $t | select($pairs | any(.version == $t.version and .variant == $t.variant))]' <<< "$ALL_TRIPLES")

          # 3. Detect changed versions.json entries (per-arch digest and base changes)
          BASE_VERSIONS=$(git show "${BASE_SHA}:versions.json" 2>/dev/null || echo '{}')
          CHANGED_VJ=$(jq -c --argjson base "$BASE_VERSIONS" '
            [to_entries[] | .key as $ver | .value | to_entries[] |
             select(.value | type == "object" and has("base")) |
             .key as $var | .value |
             . as $variant |
             to_entries[] |
             select(.key != "base" and (.value | type == "object" and has("digest"))) |
             {version: ($ver | ltrimstr("ubi")), variant: $var, arch: .key,
              base: $variant.base, digest: .value.digest} |
             select(
               ($base[("ubi" + .version)]?[.variant]?.base // null) != .base or
               ($base[("ubi" + .version)]?[.variant]?[.arch]?.digest // null) != .digest
             ) |
             {version, variant, arch}
            ]' versions.json)
          echo "Changed versions.json entries: $CHANGED_VJ"

          # 4. Union and deduplicate
          UNION=$(jq -c -n --argjson cf "$CHANGED_CF" --argjson vj "$CHANGED_VJ" \
            '($cf + $vj) | unique')

          # 5. Validate against all valid triples (filter out deleted entries)
          FILTERED=$(jq -c --argjson all "$ALL_TRIPLES" \
            '[.[] | . as $item | select($all | any(. == $item))]' <<< "$UNION")
          echo "Filtered changes: $FILTERED"

          # 6. Fallback to all triples if nothing changed
          if [[ "$FILTERED" == "[]" ]]; then
            echo "No specific changes detected, falling back to all valid triples"
            FILTERED="$ALL_TRIPLES"
          fi

          echo "Final matrix: $FILTERED"
          echo "matrix=$FILTERED" >> $GITHUB_OUTPUT
          echo "$FILTERED" > build-matrix.json

      - name: Upload build matrix
        uses: actions/upload-artifact@v4
        with:
          name: build-matrix
          path: build-matrix.json

  build-and-sign:
    name: Build UBI Variant
    needs: matrix-setup
    runs-on: ${{ matrix.arch == 'arm64' && 'ubuntu-24.04-arm' || 'ubuntu-latest' }}
    environment: Build-Actor
    permissions:
      contents: read
      packages: write
      id-token: write # Required if you eventually use keyless signing

    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJSON(needs.matrix-setup.outputs.matrix) }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3.4.0

      - name: Install Syft & Grype
        run: |
          curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin
          curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh -s -- -b /usr/local/bin

      - name: Install Buildah
        run: |
          sudo apt-get update
          sudo apt-get install -y buildah

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Load Upstream Metadata
        id: metadata
        run: |
          KEY_VER="ubi${{ matrix.version }}"
          VAR="${{ matrix.variant }}"
          ARCH="${{ matrix.arch }}"

          BASE=$(jq -r ".$KEY_VER.$VAR.base" versions.json)
          DIGEST=$(jq -r ".$KEY_VER.$VAR.$ARCH.digest" versions.json)
          
          # Safety check: fail if jq returns null (variant not defined in JSON)
          if [[ "$BASE" == "null" ]]; then
            echo "Error: Variant $VAR not found for $KEY_VER in versions.json"
            exit 1
          fi

          echo "base=$BASE" >> $GITHUB_OUTPUT
          echo "digest=$DIGEST" >> $GITHUB_OUTPUT

      - name: Build Image with Buildah
        id: build
        env:
          REGISTRY: ghcr.io/${{ github.repository }}/development
          PR_NUM: ${{ github.event.pull_request.number }}
        run: |
          IMAGE_NAME="${REGISTRY}/ubi${{ matrix.version }}-${{ matrix.variant }}"
          TAG="pr-${PR_NUM}-${{ matrix.arch }}"
          
          echo "Building Development Image: $IMAGE_NAME:$TAG"
          
          # 1. Build the image (added IMAGE_VERSION to silence warning)
          buildah bud \
            --platform linux/${{ matrix.arch }} \
            --build-arg UPSTREAM_BASE="${{ steps.metadata.outputs.base }}" \
            --build-arg UPSTREAM_DIGEST="${{ steps.metadata.outputs.digest }}" \
            --build-arg IMAGE_VERSION="${{ github.ref_name }}" \
            --build-arg GIT_COMMIT="${{ github.sha }}" \
            --build-arg BUILD_DATE="$(date -u +'%Y-%m-%dT%H:%M:%SZ')" \
            --build-arg TARGETARCH="${{ matrix.arch }}" \
            -t "$IMAGE_NAME:$TAG" \
            -f Containerfiles/ubi${{ matrix.version }}-${{ matrix.variant }}.Containerfile .
          
          # 2. Push the image and capture the pushed manifest digest
          buildah push --digestfile ./pushed-digest.txt "$IMAGE_NAME:$TAG"
          PUSHED_DIGEST=$(cat ./pushed-digest.txt)
          IMAGE_URI="$IMAGE_NAME@$PUSHED_DIGEST"

          # 3. Export to local OCI directory for Syft/Grype scanning
          buildah push "$IMAGE_NAME:$TAG" oci:./oci-image

          echo "image_uri=$IMAGE_URI" >> $GITHUB_OUTPUT
          echo "image_name=$IMAGE_NAME" >> $GITHUB_OUTPUT
          echo "digest=$PUSHED_DIGEST" >> $GITHUB_OUTPUT

      - name: Generate Evidence Artifacts
        env:
          LOCAL_IMAGE: "oci-dir:./oci-image"
        run: |
          echo "Generating SBOM (Syft) from local storage..."
          syft "${{ env.LOCAL_IMAGE }}" -o spdx-json=sbom.json

          echo "Scanning for vulnerabilities (Grype) from local storage..."
          grype "${{ env.LOCAL_IMAGE }}" -o json > cve-report.json

          echo "Fetching GitHub Actions OIDC token..."
          OIDC_TOKEN=$(curl -sS -H "Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN" \
            "${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=sigstore" | jq -r '.value')

          echo "Capturing build tool versions..."
          BUILDAH_VERSION=$(buildah --version | awk '{print $3}')
          COSIGN_VERSION=$(cosign version --json | jq -r '.gitVersion')
          SYFT_VERSION=$(syft --version | awk '{print $2}')
          GRYPE_VERSION=$(grype --version | awk '{print $2}')

          echo "Generating SLSA v1.0 build provenance..."
          jq -n \
            --arg buildType "https://github.com/${{ github.repository }}/build/v1" \
            --arg sourceUri "git+https://github.com/${{ github.repository }}@${{ github.ref }}" \
            --arg sourceDigest "${{ github.sha }}" \
            --arg variant "${{ matrix.variant }}" \
            --arg version "ubi${{ matrix.version }}" \
            --arg arch "${{ matrix.arch }}" \
            --arg containerfile "Containerfiles/ubi${{ matrix.version }}-${{ matrix.variant }}.Containerfile" \
            --arg platform "linux/${{ matrix.arch }}" \
            --arg buildahVersion "$BUILDAH_VERSION" \
            --arg cosignVersion "$COSIGN_VERSION" \
            --arg syftVersion "$SYFT_VERSION" \
            --arg grypeVersion "$GRYPE_VERSION" \
            --arg upstreamBase "${{ steps.metadata.outputs.base }}" \
            --arg upstreamDigest "${{ steps.metadata.outputs.digest }}" \
            --arg builderId "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}" \
            --arg invocationId "${{ github.run_id }}/${{ github.run_attempt }}" \
            --arg startedOn "$(date -u +'%Y-%m-%dT%H:%M:%SZ')" \
            --arg oidcToken "$OIDC_TOKEN" \
            --arg imageUri "${{ steps.build.outputs.image_uri }}" \
            --arg imageDigest "${{ steps.build.outputs.digest }}" \
            '{
              "buildDefinition": {
                "buildType": $buildType,
                "externalParameters": {
                  "source": {
                    "uri": $sourceUri,
                    "digest": { "sha1": $sourceDigest }
                  },
                  "variant": $variant,
                  "version": $version,
                  "arch": $arch
                },
                "internalParameters": {
                  "containerfile": $containerfile,
                  "platform": $platform,
                  "oidcToken": $oidcToken,
                  "output": {
                    "uri": $imageUri,
                    "digest": { "sha256": ($imageDigest | ltrimstr("sha256:")) }
                  }
                },
                "resolvedDependencies": [
                  {
                    "uri": $upstreamBase,
                    "digest": { "sha256": ($upstreamDigest | ltrimstr("sha256:")) }
                  }
                ]
              },
              "runDetails": {
                "builder": {
                  "id": $builderId,
                  "version": {
                    "buildah": $buildahVersion,
                    "cosign": $cosignVersion,
                    "syft": $syftVersion,
                    "grype": $grypeVersion
                  }
                },
                "metadata": {
                  "invocationId": $invocationId,
                  "startedOn": $startedOn
                }
              }
            }' > provenance.json

      - name: Sign Evidence Blobs
        env:
          COSIGN_PRIVATE_KEY: ${{ secrets.COSIGN_PRIVATE_KEY }}
        run: |
          echo "Signing artifacts with Build-Actor sovereign key..."
          cosign sign-blob --tlog-upload=false --key env://COSIGN_PRIVATE_KEY \
            --output-signature sbom.json.sig sbom.json

          cosign sign-blob --tlog-upload=false --key env://COSIGN_PRIVATE_KEY \
            --output-signature cve-report.json.sig cve-report.json

          cosign sign-blob --tlog-upload=false --key env://COSIGN_PRIVATE_KEY \
            --output-signature provenance.json.sig provenance.json

      - name: Attach Attestations to GHCR Image
        env:
          COSIGN_PRIVATE_KEY: ${{ secrets.COSIGN_PRIVATE_KEY }}
          IMAGE_URI: ${{ steps.build.outputs.image_uri }}
        run: |
          echo "Attaching SBOM attestation..."
          cosign attest --yes --replace --tlog-upload=false \
            --key env://COSIGN_PRIVATE_KEY \
            --type spdxjson --predicate sbom.json "$IMAGE_URI"

          echo "Attaching CVE report attestation..."
          cosign attest --yes --replace --tlog-upload=false \
            --key env://COSIGN_PRIVATE_KEY \
            --type vuln --predicate cve-report.json "$IMAGE_URI"

          echo "Attaching SLSA provenance attestation..."
          cosign attest --yes --replace --tlog-upload=false \
            --key env://COSIGN_PRIVATE_KEY \
            --type slsaprovenance1 --predicate provenance.json "$IMAGE_URI"

      - name: Generate Evidence Checksums
        env:
          COSIGN_PRIVATE_KEY: ${{ secrets.COSIGN_PRIVATE_KEY }}
        run: |
          sha256sum sbom.json sbom.json.sig cve-report.json cve-report.json.sig provenance.json provenance.json.sig > checksums.sha256
          cosign sign-blob --tlog-upload=false --key env://COSIGN_PRIVATE_KEY \
            --output-signature checksums.sha256.sig checksums.sha256

      - name: Upload Evidence Bundle
        uses: actions/upload-artifact@v4
        with:
          name: evidence-ubi${{ matrix.version }}-${{ matrix.variant }}-${{ matrix.arch }}
          path: |
            sbom.json
            sbom.json.sig
            cve-report.json
            cve-report.json.sig
            provenance.json
            provenance.json.sig
            checksums.sha256
            checksums.sha256.sig